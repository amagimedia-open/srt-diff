#!/bin/bash

set -u
#set -x

#----[temp files and termination]--------------------------------------------

TERMINATED=0

function fnxOnEnd
{
    ((TERMINATED==0)) && { rm -f $TMP1 $TMP2 $DEF_RANGE_SPEC_FILE_PATH; }
    TERMINATED=1
}

TMP1=`mktemp`
TMP2=`mktemp`
DEF_RANGE_SPEC_FILE_PATH=`mktemp`

trap 'fnxOnEnd;' 0 1 2 3 6 9 11

#----[globals]------------------------------------------------------------------------

DIRNAME=$(readlink -e $(dirname $0))
MODNAME=$(basename $0)

G_MAPPED_ROOT_PATH=/data

cat <<EOD >$DEF_RANGE_SPEC_FILE_PATH

BEGIN_I,END_E,NAME
0,25,0000-0025-ms
25,50,0025-0050-ms
50,100,0050-0100-ms
100,200,0100-0200-ms
200,500,0200-0500-ms
500,1000,0500-1000-ms
1000,2000,1000-2000-ms
2000,*,2000-****-ms
EOD

#----[sources]---------------------------------------------------------------

source $DIRNAME/common_bash_functions.sh

#----[options]---------------------------------------------------------------

OPT_RANGE_SPEC_FILE_PATH=$DEF_RANGE_SPEC_FILE_PATH
OPT_SRT_LEV_FILE_PATH=""
OPT_DEBUG=0

#----[helper functions]------------------------------------------------------

function usage
{
    cat <<EOD
NAME

    $MODNAME - Dumps histogram values using a srtlev.csv file.
                   
SYNOPSIS

    $MODNAME -r range_spec_filepath [-h] [srtlev_filepath]
             
DETAILS

    The srtlev_filepath is the levenshtein details in csv format
    generated by the srt_diff.sh script. if srtlev_filepath is not 
    specified, stdin is used.

    The range_spec_filepath must be as follows
    BEGIN_I, END_E, NAME
    ......,  ....,  ....
    ......,  ....,  ....
    where BEGIN_I => range BEGIN Inclusive
    and   END_E   => range END   Exclusive 
    i.e. [BEGIN_I, END_E[

    The default range_spec_filepath is as follows:
    `cat $DEF_RANGE_SPEC_FILE_PATH | sed 's/^/    /'`

OPTIONS

    -r  range_spec_filepath
        this is optional.

    -h
        Displays this help and quits.
        This is optional.
EOD
}

#----------------------------------------------------------------------------
# MAIN
#----------------------------------------------------------------------------

#+---------------------+
#| argument processing |
#+---------------------+

TEMP=`getopt -o "r:h" -n "$0" -- "$@"`
eval set -- "$TEMP"

while true 
do
	case "$1" in
        -r) OPT_RANGE_SPEC_FILE_PATH=$2; shift 2;;
        -h) usage; exit 0;;
		--) shift ; break ;;
		*) echo "Internal error!" ; exit 1 ;;
	esac
done

if [[ ! -f $OPT_RANGE_SPEC_FILE_PATH ]]
then
    error_message "$OPT_RANGE_SPEC_FILE_PATH not present"
    exit 1
fi

OPT_SRT_LEV_FILE_PATH=${1-""}

if [[ -n $OPT_SRT_LEV_FILE_PATH ]]
then
    if [[ ! -f $OPT_SRT_LEV_FILE_PATH ]]
    then
        error_message "$OPT_SRT_LEV_FILE_PATH not present"
        exit 1
    fi
fi

#+-------------------------+
#| generate histogram data |
#+-------------------------+

cat $OPT_SRT_LEV_FILE_PATH  |\
gawk -F ',' '{ print $6; }' |\
gawk -F ',' \
     -v v_rangespec_filepath=$OPT_RANGE_SPEC_FILE_PATH \
     -v v_debug=$OPT_DEBUG \
'
    BEGIN \
    {
        error = 0
        n_buckets = 0
        line_num = 0
        header_seen = 0
        header_line = ""
        n_records = 0

        while ((getline line < v_rangespec_filepath) > 0)
        {
            if (line ~ /^[ \t]*$/)
            {
                ++line_num
                continue
            }

            if (! header_seen)
            {
                header_line = line
                header_seen = 1
                continue
            }

            n = split(line, t_arr, ",")
            if (n != 3)
            {
                print n " tokens found at line " line_num " in " v_rangespec_filepath > "/dev/stderr"
                error = 1
                exit(1)
            }

            rbegin[n_buckets] = t_arr[1]
            rend[n_buckets]   = t_arr[2]
            rname[n_buckets]  = t_arr[3]

            ++line_num
            ++n_buckets
        }
        close(v_rangespec_filepath)

        if (n_buckets == 0)
        {
            print "no records found in in " v_rangespec_filepath > "/dev/stderr"
            error = 1
            exit(1)
        }

        if (v_debug)
        {
            print "d> N " n_buckets
            print "d> H " header_line > "/dev/stderr"
            for (j = 0; j < n_buckets; ++j)
                print "d> R " rbegin[j] "," rend[j] "," rname[j] > "/dev/stderr"
        }
    }

    {
        if (NF == 0)
            next

        ++n_records

        for (j = 0; j < n_buckets; ++j)
        {
            if ($1 >= rbegin[j])
                if (rend[j] == "*" || $1 < rend[j])
                    ++hist[rname[j]]
        }
    }

    END \
    {
        if (error)
            exit(1)

        print "NAME,VALUE,NRECORDS"
        for (j = 0; j < n_buckets; ++j)
            print rname[j] "," hist[rname[j]] "," n_records
    }
'


